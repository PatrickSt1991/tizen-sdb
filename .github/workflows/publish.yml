name: Build & Draft Release (multi-rid AOT)

on:
  workflow_dispatch:
    inputs:
      tag:
        description: 'Tag to create (example: v1.2.3). If empty a generated tag will be used.'
        required: false
        default: ''
  push:
    tags:
      - 'v*'

permissions:
  contents: write

env:
  DOTNET_VERSION: '8.0.x'
  CSPROJ: 'tizenSdb/tizen-sdb.csproj'
  OUTPUT_BASE: ${{ github.workspace }}/artifacts

jobs:
  build:
    name: Publish for multiple runtimes
    runs-on: ${{ matrix.runner }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - rid: linux-x64
            runner: ubuntu-latest
          - rid: win-x64
            runner: windows-latest
          - rid: osx-x64
            runner: macos-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get version from tag
        id: get_version
        shell: bash
        run: |
          if [[ "${{ github.ref }}" == refs/tags/* ]]; then
            VERSION="${GITHUB_REF#refs/tags/}"
          else
            VERSION="v0.0.0-placeholder"
          fi
          echo "version=${VERSION}" >> "$GITHUB_OUTPUT"

      - name: Setup .NET ${{ env.DOTNET_VERSION }}
        uses: actions/setup-dotnet@v3
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Restore (project + rid)
        shell: bash
        run: |
          dotnet restore "${{ env.CSPROJ }}" -r "${{ matrix.rid }}"

      - name: Publish (AOT, self-contained) for ${{ matrix.rid }}
        shell: bash
        run: |
          RID="${{ matrix.rid }}"
          OUT="${{ env.OUTPUT_BASE }}/${RID}"
          mkdir -p "$OUT"
          dotnet publish "${{ env.CSPROJ }}" -c Release -r "$RID" -p:PublishAot=true -p:PublishTrimmed=true --self-contained true -o "$OUT/publish" --no-restore

      - name: Prepare versioned executable
        shell: bash
        run: |
          set -e
          RID="${{ matrix.rid }}"
          OUT_DIR="${{ env.OUTPUT_BASE }}/${RID}/publish"
          DEST_DIR="${{ env.OUTPUT_BASE }}/${RID}/final"
          mkdir -p "$DEST_DIR"

          VERSION="${{ steps.get_version.outputs.version }}"

          if [[ "$RID" == win-* ]]; then
            FINAL_NAME="TizenSdb_${VERSION}.exe"
            SOURCE_FILE=$(find "$OUT_DIR" -maxdepth 1 -name "TizenSdb.exe" -type f | head -1)
            if [ -z "$SOURCE_FILE" ]; then
              echo "Error: Could not find TizenSdb.exe in $OUT_DIR"
              echo "Contents of $OUT_DIR:"
              ls -la "$OUT_DIR"
              exit 1
            fi
            cp "$SOURCE_FILE" "$DEST_DIR/$FINAL_NAME"
          elif [[ "$RID" == linux-* ]]; then
            FINAL_NAME="TizenSdb_${VERSION}_linux"
            SOURCE_FILE=$(find "$OUT_DIR" -maxdepth 1 -name "TizenSdb*" -type f ! -name "*.exe" ! -name "*.pdb" ! -name "*.dbg" | head -1)
            if [ -z "$SOURCE_FILE" ]; then
              echo "Error: Could not find TizenSdb binary in $OUT_DIR"
              ls -la "$OUT_DIR"
              exit 1
            fi
            cp "$SOURCE_FILE" "$DEST_DIR/$FINAL_NAME"
            chmod +x "$DEST_DIR/$FINAL_NAME"
          elif [[ "$RID" == osx-x64 ]]; then
            FINAL_NAME="TizenSdb_${VERSION}_macos"
            SOURCE_FILE=$(find "$OUT_DIR" -maxdepth 1 -name "TizenSdb*" -type f ! -name "*.exe" ! -name "*.pdb" ! -name "*.dbg" | head -1)
            if [ -z "$SOURCE_FILE" ]; then
              echo "Error: Could not find TizenSdb binary in $OUT_DIR"
              ls -la "$OUT_DIR"
              exit 1
            fi
            cp "$SOURCE_FILE" "$DEST_DIR/$FINAL_NAME"
            chmod +x "$DEST_DIR/$FINAL_NAME"
          fi

          echo "Final executable: $FINAL_NAME"

      - name: Upload raw executables as artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.rid }}
          path: ${{ env.OUTPUT_BASE }}/${{ matrix.rid }}/final/

  create_release:
    name: Create draft release and attach executables
    runs-on: ubuntu-latest
    needs: build
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'

    steps:
      - name: Download all build artifacts
        uses: actions/download-artifact@v4
        with:
          path: ./downloaded_artifacts

      - name: Get or generate release tag
        id: version
        shell: bash
        run: |
          set -e
          INPUT_TAG="${{ github.event.inputs.tag }}"

          if [ -n "$INPUT_TAG" ]; then
            echo "Using user-provided tag: $INPUT_TAG"
            NEXT_TAG="$INPUT_TAG"
          elif [[ "${{ github.ref }}" == refs/tags/* ]]; then
            NEXT_TAG="${GITHUB_REF#refs/tags/}"
            echo "Using pushed tag: $NEXT_TAG"
          else
            echo "Auto-incrementing version based on latest release..."

            LATEST_TAG=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              "https://api.github.com/repos/${{ github.repository }}/releases/latest" | \
              grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\1/' || echo "")

            if [ -z "$LATEST_TAG" ]; then
              echo "No existing releases found, starting with v1.0.0"
              NEXT_TAG="v1.0.0"
            else
              echo "Latest tag found: $LATEST_TAG"

              if [[ $LATEST_TAG =~ ^v([0-9]+)\.([0-9]+)\.([0-9]+)$ ]]; then
                MAJOR=${BASH_REMATCH[1]}
                MINOR=${BASH_REMATCH[2]}
                PATCH=${BASH_REMATCH[3]}

                PATCH=$((PATCH + 1))

                NEXT_TAG="v${MAJOR}.${MINOR}.${PATCH}"
                echo "Incremented version: $LATEST_TAG -> $NEXT_TAG"
              else
                echo "Warning: Latest tag doesn't match semantic version pattern"
                NEXT_TAG="v${{ github.run_number }}-${{ github.run_id }}"
              fi
            fi
          fi

          echo "tag=${NEXT_TAG}" >> "$GITHUB_OUTPUT"

      - name: Rename artifacts with final version
        shell: bash
        run: |
          set -e
          FINAL_VERSION="${{ steps.version.outputs.tag }}"
          echo "Renaming artifacts to use final version: $FINAL_VERSION"

          find downloaded_artifacts -type f -name '*v0.0.0-placeholder*' -print0 | while IFS= read -r -d '' file; do
            new_file=$(echo "$file" | sed "s/v0\.0\.0-placeholder/$FINAL_VERSION/g")
            mv "$file" "$new_file"
          done

      - name: Create a draft release
        id: create_release
        uses: actions/create-release@v1
        with:
          tag_name: ${{ steps.version.outputs.tag }}
          release_name: ${{ steps.version.outputs.tag }}
          draft: true
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload release assets
        shell: bash
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          UPLOAD_URL: ${{ steps.create_release.outputs.upload_url }}
        run: |
          set -e
          UPLOAD_URL_TEMPLATE="${UPLOAD_URL}"
          UPLOAD_URL="${UPLOAD_URL_TEMPLATE%\{*}"
          echo "Base upload URL: $UPLOAD_URL"

          find downloaded_artifacts -type f \( -name 'TizenSdb_*' ! -name '*.md5' \) -print0 | while IFS= read -r -d '' file; do
            name=$(basename "$file")
            echo "Uploading $name ..."

            if [[ "$file" == *.exe ]]; then
              CONTENT_TYPE="application/vnd.microsoft.portable-executable"
            else
              CONTENT_TYPE="application/octet-stream"
            fi

            curl --fail -sS -X POST \
              -H "Authorization: token ${GITHUB_TOKEN}" \
              -H "Content-Type: ${CONTENT_TYPE}" \
              --data-binary "@${file}" \
              "${UPLOAD_URL}?name=$(printf '%s' "$name" | jq -s -R -r @uri)"
            echo "Uploaded $name"
          done

      - name: Show release URL
        run: |
          echo "Draft release created: https://github.com/${{ github.repository }}/releases/tag/${{ steps.version.outputs.tag }}"
